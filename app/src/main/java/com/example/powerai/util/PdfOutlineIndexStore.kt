package com.example.powerai.util

import android.content.Context
import com.google.gson.Gson
import java.io.File
import java.security.MessageDigest

/**
 * Reads preprocessed PDF outline index from assets (generated by tools/build_pdf_outline_index.py).
 *
 * Contract: data must come from preprocessed JSON/DB, not runtime PDF parsing.
 */
object PdfOutlineIndexStore {
    private const val ASSET_FILE = "pdf_outline_index.json"

    data class IndexFile(
        val version: Int = 1,
        val generatedAt: String? = null,
        val pdfs: Map<String, PdfEntry> = emptyMap()
    )

    data class PdfEntry(
        val assetPath: String? = null,
        val fileName: String? = null,
        val pageCount: Int? = null,
        val sections: List<Section> = emptyList()
    )

    data class Section(
        val startPage: Int = 1,
        val path: List<String> = emptyList()
    )

    @Volatile
    private var cached: IndexFile? = null

    private fun loadOnce(context: Context): IndexFile? {
        cached?.let { return it }
        synchronized(this) {
            cached?.let { return it }
            val json = try {
                context.assets.open(ASSET_FILE).bufferedReader(Charsets.UTF_8).use { it.readText() }
            } catch (_: Throwable) {
                return null
            }
            val parsed = try {
                Gson().fromJson(json, IndexFile::class.java)
            } catch (_: Throwable) {
                null
            }
            cached = parsed
            return parsed
        }
    }

    fun breadcrumbFor(context: Context, fileId: String, pageNumber: Int): List<String>? {
        val idx = loadOnce(context) ?: return null
        val entry = idx.pdfs[fileId.lowercase()] ?: return null
        val sections = entry.sections
        if (sections.isEmpty()) return null

        // sections are sorted by startPage asc (generator guarantees it).
        var lo = 0
        var hi = sections.lastIndex
        var best: Section? = null
        while (lo <= hi) {
            val mid = (lo + hi) ushr 1
            val s = sections[mid]
            if (s.startPage <= pageNumber) {
                best = s
                lo = mid + 1
            } else {
                hi = mid - 1
            }
        }
        return best?.path?.filter { it.isNotBlank() }?.takeIf { it.isNotEmpty() }
    }

    fun assetPathFor(context: Context, fileId: String): String? {
        val idx = loadOnce(context) ?: return null
        return idx.pdfs[fileId.lowercase()]?.assetPath
    }

    fun labelForPath(path: List<String>?): String? {
        val p = path ?: return null
        if (p.isEmpty()) return null

        val chapterRegex = Regex("^第.+章")
        if (p.any { chapterRegex.containsMatchIn(it) }) return "正文"
        if (p.any { it.contains("目录") }) return "目录"
        // Common front-matter markers
        if (p.any { it.contains("前") || it.contains("序") || it.contains("编审") }) return "目录"

        return "正文"
    }

    /**
     * Best-effort: if internal cached PDF is missing, restore it from assets using the prebuilt index.
     * Returns true if the PDF becomes available locally.
     */
    fun restorePdfFromAssetsIfPossible(context: Context, fileId: String): Boolean {
        val dst = PdfStorage.getPdfFile(context, fileId)
        if (dst.exists()) return true

        val assetPath = assetPathFor(context, fileId) ?: return false
        val dir = dst.parentFile ?: return false
        if (!dir.exists()) dir.mkdirs()

        val tmp = File(dir, "$fileId.tmp")
        try {
            context.assets.open(assetPath).use { input ->
                val md = MessageDigest.getInstance("SHA-256")
                tmp.outputStream().use { out ->
                    val buf = ByteArray(1024 * 64)
                    while (true) {
                        val n = input.read(buf)
                        if (n <= 0) break
                        md.update(buf, 0, n)
                        out.write(buf, 0, n)
                    }
                }
                val sha = md.digest().joinToString("") { "%02x".format(it) }
                if (!sha.equals(fileId, ignoreCase = true)) {
                    tmp.delete()
                    return false
                }
            }
            if (dst.exists()) dst.delete()
            return tmp.renameTo(dst) && dst.exists()
        } catch (_: Throwable) {
            tmp.delete()
            return false
        }
    }
}
